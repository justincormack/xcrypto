\subsection{\XCID instructions}
\label{sec:spec:instruction}

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:spec:instruction:1}

% -----------------------------------------------------------------------------

\XCINSTR{xc.xcr2gpr}{rd, crs1}{
  Move an $\XCR$ register to a $\GPR$ register.
}{ 
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gpr2xcr}{crd, rs1}{
  Move a $\GPR$ register to an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \GPR[*][{\VERB[RV]{rs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.t}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] \neq 0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.f}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] =    0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.bu}{crd, h, b, imm11(rs1)}{
  Load a     byte from memory
  into a specific     byte of an $\XCR$ register.
  If \VERB[RV]{h} or \VERB[RV]{b} are non-zero,
  the other bytes in the destination register are left un-modified.
  If \VERB[RV]{h} and \VERB[RV]{b} are zero,
  the least-significant byte of the destination register
  is set to the loaded byte, and all other bytes in the
  destination register are cleared.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index                                         \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hu}{crd, h,    imm11(rs1)}{
  Load a halfword from memory
  into a specific halfword of an $\XCR$ register,
  If \VERB[RV]{h} is non-zero,
  the low halfword of the destination register is left un-modified.
  If \VERB[RV]{h} is zero,
  the least-significant halfword of the destination register
  is set to the loaded halfword, and all other halfwords in the
  destination register are cleared.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0$ \;
  $index_1                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  \If{$index_0 = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.w} {crd,        imm11(rs1)}{
  Load a     word from memory 
  into                        an $\XCR$ register.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN                                            0$ \;
  $index_1                                       \ASN                                            1$ \;
  $index_2                                       \ASN                                            2$ \;
  $index_3                                       \ASN                                            3$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.b} {rs2, h, b, imm11(rs1)}{
  Store a specific     byte of an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index           \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\MEM[*][addr  ] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  }$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.h} {rs2, h,    imm11(rs1)}{
  Store a specific halfword of an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0$ \;
  $index_1         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.w} {rs2,       imm11(rs1)}{
  Store                        an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN                                            0$ \;
  $index_1         \ASN                                            1$ \;
  $index_2         \ASN                                            2$ \;
  $index_3         \ASN                                            3$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
  $\MEM[*][addr+2] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2}$ \;
  $\MEM[*][addr+3] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3}$ \;
}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:spec:instruction:2:1}

\XCINSTR{xc.rngtest}{rd1}{
  Inspect the RNG state, applying a suitable ``health check'' on the level 
  of entropy available: the status flag is stored in a $\GPR$ register.
  If, after execution \VERB[RV]{xc.rngseed},
         $\GPR[*][{\VERB[RV]{rd1}}] \neq 0$
  (resp. $\GPR[*][{\VERB[RV]{rd1}}] =    0$),
  then the RNG has 
           sufficient 
  (resp. insufficient)
  entropy; the next output sampled via \VERB[RV]{xc.rngsamp} 
  therefore
         can
  (resp. cannot, or at least should not)
  be used.
}{
  $\GPR[*][{\VERB[RV]{rd1}}] \TEST{\ASN} \RNG$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngseed}{crs1}{
  Inject (or seed) $32$-bits of entropy into the RNG, reading from an $\XCR$ register.
}{
  $\RNG \ASN \XCR[*][{\VERB[RV]{crs1}}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngsamp}{crd}{
  Sample           $32$-bits of entropy from the RNG, writing to   an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \RNG$ \;
}

% =============================================================================

\subsubsection{Class-$2.2$: memory}
\label{sec:spec:instruction:2:2}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.b}{crd, rs2, crs2}{
  Perform a ``scattered'' store of 
  four     bytes 
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a     byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\MEM[*][addr_0  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_1  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_2  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_3  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.h}{crd, rs2, crs2}{
  Perform a ``scattered'' store of 
  two  halfwords
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a halfword within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\MEM[*][addr_0+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_0+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_1+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_1+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.b}{crd, rs1, crs2}{
  Perform a  ``gathered''  load of 
  four     bytes 
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a     byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_1  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_2  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_3  ]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.h}{rd, rs1, crs2}{
  Perform a  ``gathered''  load of 
  two  halfwords
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a halfword within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_0+1]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_1+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_1+1]$ \;
}

% =============================================================================

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:spec:instruction:2:3}

\XCINSTR{xc.ld.liu}{crd, imm16}{
  Load an immediate halfword
  into the lower (or least-significant) halfword of an $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hiu}{crd, imm16}{
  Load an immediate halfword
  into the upper (or  most-significant) halfword of an $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.bop}{crd, crs1, crs2, lut4}{
  Compute each $i$-bit of a $32$-bit result by applying a given $2$-input, 
  $1$-output Boolean function $f$ to corresponding $i$-th bits of the two 
  operands.  The function $f$ is specified as a truth-table encoded as the
  immediate \VERB[RV]{lut4}: given
  \[
  \begin{array}{|cc|c|}
  \hline
  \multicolumn{3}{|c|}{f}     \\
  \hline
  x_i & y_i & r_i               \\
  \hline
    0 &   0 & \VERB[RV]{lut4}_0 \\
    0 &   1 & \VERB[RV]{lut4}_1 \\
    1 &   0 & \VERB[RV]{lut4}_2 \\
    1 &   1 & \VERB[RV]{lut4}_3 \\
  \hline
  \end{array}
  \]
  the instruction essentially computes
  $
  \INDEX{r}{i} = f( \INDEX{x}{i}, \INDEX{y}{i} ) = \INDEX{\VERB[RV]{lut4}}{x_i \CONS y_i}
  $
  for $x$, $y$, and $r$, all in $\XCR$ registers.  Note that since
  \[
  \begin{array}{l@{\;}c@{\;}l c l@{\;}c@{\;}l}
  \VERB[RV]{lut4} &=& \RADIX{1000}{2} &\Longrightarrow& f &=& \AND \\
  \VERB[RV]{lut4} &=& \RADIX{1110}{2} &\Longrightarrow& f &=& \IOR \\
  \VERB[RV]{lut4} &=& \RADIX{0110}{2} &\Longrightarrow& f &=& \XOR \\
  \end{array}
  \]
  \VERB[RV]{xc.bop} can be used to synthesise a set of standard Boolean
  instructions (e.g., by analogy, per those in RV32I).
}{
  \For{$i = 0$ {\bf upto} $31$} {
    $index \ASN \INDEX{\XCR[*][crs1]}{i} \CONS \INDEX{\XCR[*][crs2]}{i}$ \;
    $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\VERB[RV]{lut4}}{index}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ext}{crd, crs, cs, cl}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from             one $\XCR$ register, and
  insert them as the LSBs in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \ASN \INDEX{\XCR[*][{\VERB[RV]{crs}}]}{hi \RANGE lo}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ins}{crd, crs, cs, cl}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from the LSBs of one $\XCR$ register, and
  insert   them           in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crs}}]}{hi \RANGE lo}$ \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mix.l}{rd, rs1, rs2, rtamt}{
  Form a result by mix together bits from two operands based on a mask:
  the instruction essentially computes  
  \[
  \INDEX{r}{i} = \left\{\begin{array}{ll}
                        \INDEX{x}{i} \OP[32][u]{\RRT}   \VERB[RV]{rtamt}        & \mbox{~if $\INDEX{m}{i} = 1$} \\
                        \INDEX{r}{i}                                            & \mbox{~otherwise            } \\
                        \end{array}
                        \right.
  \]
  for $r$, $x$, and $m$ in $\XCR$ registers,
  and for each 
  $
  0 \leq i < 32 .
  $ 
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT}   \VERB[RV]{rtamt}       $ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \If{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 1$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mix.h}{rd, rs1, rs2, rtamt}{
  Form a result by mix together bits from two operands based on a mask:
  the instruction essentially computes  
  \[
  \INDEX{r}{i} = \left\{\begin{array}{ll}
                        \INDEX{x}{i} \OP[32][u]{\RRT} ( \VERB[RV]{rtamt} + 16 ) & \mbox{~if $\INDEX{m}{i} = 1$} \\
                        \INDEX{r}{i}                                            & \mbox{~otherwise            } \\
                        \end{array}
                        \right.
  \]
  for $r$, $x$, and $m$ in $\XCR$ registers,
  and for each 
  $
  0 \leq i < 32 .
  $ 
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT} ( \VERB[RV]{rtamt} + 16 )$ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \If{$\INDEX{\XCR[*][{\VERB[RV]{rs2}}]}{i} = 1$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }
  }
}

% =============================================================================

\subsubsection{Class-$2.4$: packed}
\label{sec:spec:instruction:2:4}

Each instruction in this class computes a packed operation: for an operator
$\odot$, register or immediate variants essentially compute

\begin{enumerate}
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot} \INDEX[w]{y}{i}$,
      for $r$, $x$, and $y$ in $\XCR$ registers.
      and
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot}           y    $,
      for $r$       and $x$ in $\XCR$ registers, and an immediate $y$,
\end{enumerate}

\noindent
and for each 
$
0 \leq i < \VERB[RV]{n} ,
$ 
where the field count
$
\VERB[RV]{n} \in \SET{ 2, 4, 8, 16, 32 }
$ 
specified in the instruction encoding implies a field width of 
$
w = 32 / \VERB[RV]{n} .
$
As such, said encoding yields the following cases
\[
\begin{array}{ccrcc@{\;}c@{\;}rc@{\;}c@{\;}r}
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{000}{2} &\mapsto& \VERB[RV]{n} &=&  1 & w &=& 32     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{001}{2} &\mapsto& \VERB[RV]{n} &=&  2 & w &=& 16     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{010}{2} &\mapsto& \VERB[RV]{n} &=&  4 & w &=&  8     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{011}{2} &\mapsto& \VERB[RV]{n} &=&  8 & w &=&  4     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{100}{2} &\mapsto& \VERB[RV]{n} &=& 16 & w &=&  2     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{101}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{110}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{111}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\end{array}
\]
where cases marked invalid are reserved.

% -----------------------------------------------------------------------------

\XCINSTR{xc.padd}{pw, crd, crs1, crs2}{
  Compute a   register-based packed addition, 
  implying $\odot = +$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{+}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psub}{pw, crd, crs1, crs2}{
  Compute a   register-based packed subtraction, 
  implying $\odot = -$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{-}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.h},   which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.l},   which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.h}, which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.l}, which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll}{pw, crd, crs1, crs2}{
  Compute a   register-based packed left-shift,
  implying $\odot = \LSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \LSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \VERB[RV]{cshamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-shift,
  implying $\odot = \RSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \RSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \VERB[RV]{cshamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-rotate,
  implying $\odot = \RRT$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that the effective distance is
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \pmod{w} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed right-rotate,
  implying $\odot = \RRT$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that the effective distance is
  $
  \VERB[RV]{cshamt} \pmod{w} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}   \VERB[RV]{cshamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pperm.w}{crd, crs1, b0, b1, b2, b3}{
  Permute bytes   of               some $\XCR$ register,
  storing the result in               another $\XCR$ register.
}{
  $t \ASN            \XCR[*][{\VERB[RV]{crs}}]               $ \;
  $           \XCR[*][{\VERB[RV]{crd}}]                \ASN \INDEX[ 8]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pperm.hx}{crd, crs1, b0, b1, b2, b3}{
  Permute nibbles of a halfword in some $\XCR$ register,
  storing the result in a halfword of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[16]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 4]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pperm.bx}{crd, crs1, b0, b1, b2, b3}{
  Permute crumbs  of a byte     in some $\XCR$ register,
  storing the result in a byte     of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1, 2, 3 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 2]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b0}} $ \;
}

% =============================================================================

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:spec:instruction:2:5}

Instructions in this class use upto
$4$ source      $\XCR$ registers
and
$2$ destination $\XCR$ registers,
which demands some compromises wrt. the encoding used.
In short, a compressed specification of the destination $\XCR$ registers is
used, whereby a single encoded \VERB[RV]{crdm} field implies (or maps to) a 
pair 
$
\TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} }
$
of register addresses st.
a) $\VERB[RV]{crd2} = \VERB[RV]{crd1} + 1$
   (the contiguous'ness rule),
   and
b) $\VERB[RV]{crd2} = 1 \pmod{2}$
   and 
   $\VERB[RV]{crd1} = 0 \pmod{2}$
   (the  odd-even'ness rule).
Concretely then, this means
\[
\begin{array}{l@{\;}c@{\;}r c c@{\;}l@{\;}c@{\;}r@{\;}c@{\;}l@{\;}c@{\;}r@{\;}c}
\VERB[RV]{crdm} &=& \RADIX{000}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  1 &,& \VERB[RV]{crd1} &=&  0 & ) \\
\VERB[RV]{crdm} &=& \RADIX{001}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  3 &,& \VERB[RV]{crd1} &=&  2 & ) \\
\VERB[RV]{crdm} &=& \RADIX{010}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  5 &,& \VERB[RV]{crd1} &=&  4 & ) \\
\VERB[RV]{crdm} &=& \RADIX{011}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  7 &,& \VERB[RV]{crd1} &=&  6 & ) \\
\VERB[RV]{crdm} &=& \RADIX{100}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  9 &,& \VERB[RV]{crd1} &=&  8 & ) \\
\VERB[RV]{crdm} &=& \RADIX{101}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 11 &,& \VERB[RV]{crd1} &=& 10 & ) \\
\VERB[RV]{crdm} &=& \RADIX{110}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 13 &,& \VERB[RV]{crd1} &=& 12 & ) \\
\VERB[RV]{crdm} &=& \RADIX{111}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 15 &,& \VERB[RV]{crd1} &=& 14 & ) \\
\end{array}
\]
i.e.,
\[
\VERB[RV]{crdm} = x ~~\mapsto~~ \TUPLE{ \VERB[RV]{crd2} = x \CONS 1 , \VERB[RV]{crd1} = x \CONS 0 } ,
\]
noting
$\TUPLE{ 1, 0 }$ and $\TUPLE{ 3, 2 }$ are deemed valid pairs,
$\TUPLE{ 3, 0 }$ is invalid because it violates the contiguous'ness rule,
$\TUPLE{ 2, 3 }$ is invalid because it violates the contiguous'ness rule,
and
$\TUPLE{ 2, 1 }$ is invalid because it violates the  odd-even'ness rule.

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a half-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the carry-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a full-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a half-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the borrow-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a full-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{-} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.1}{(crd2, crd1), crs1      }{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs1}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.2}{(crd2, crd1), crs1, crs2}{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addends
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}] 
                                                                                                   \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate:
  the $32$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $64$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{ \times} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{ +}      \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mclmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate in $\B{F}_2[\IND]$:
  the $32$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $64$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\otimes} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{\oplus}  \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mequ}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  equality 
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_0            \AND \GPR[*][{\VERB[RV]{rs1}}]  $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mlte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
     less-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] < \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mgte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  greater-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] > \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% -----------------------------------------------------------------------------

\subsubsection{Class-$3.1$: AES}
\label{sec:spec:instruction:3:1}

\XCINSTR{xc.aessub}{mode, rot, crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt SubBytes}~\cite[Section 5.1.1]{SCARV:FIPS:197}
  operation:
  this is applicable to a column-oriented implementation of AES, whereby
  columns of the state (resp. round key) matrix are packed into $32$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  and
  $
  \VERB[RV]{rot}
  $
  control  which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l @{\;}c@{\;} r@{\;}c@{\;}l}
  \VERB[RV]{xc.aessub.enc}    &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.encrot} &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 1 \\
  \VERB[RV]{xc.aessub.dec}    &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.decrot} &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 1 \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field and
  $\VERB[RV]{rot}$  is encoded in the $\VERB[RV]{cb}$ field.
}{
  \eIf{$\VERB[RV]{mode} = 0$}{
    $t_0                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs1}]_{ 7 \RANGE  0} )$ \;
    $t_1                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs2}]_{15 \RANGE  8} )$ \;
    $t_2                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs1}]_{23 \RANGE 16} )$ \;
    $t_3                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs2}]_{31 \RANGE 24} )$ \;
  }{
    $t_0                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs1}]_{ 7 \RANGE  0} )$ \;
    $t_1                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs2}]_{15 \RANGE  8} )$ \;
    $t_2                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs1}]_{23 \RANGE 16} )$ \;
    $t_3                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs2}]_{31 \RANGE 24} )$ \;
  }
  
  \eIf{$\VERB[RV]{rot}  = 0$}{
    $\XCR[*][\OPER{crd0}] \ASN                                          t_3 \CONS t_2 \CONS t_1 \CONS t_0 $ \;
  }{
    $\XCR[*][\OPER{crd0}] \ASN                                          t_2 \CONS t_1 \CONS t_0 \CONS t_3 $ \;
  }
}

\XCINSTR{xc.aesmix}{mode,      crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt ShiftRows}~\cite[Section 5.1.2]{SCARV:FIPS:197} 
  and
  {\tt MixColumns}~\cite[Section 5.1.3]{SCARV:FIPS:197}
  operations:
  this is applicable to a column-oriented implementation of AES, whereby
  columns of the state (resp. round key) matrix are packed into $32$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  controls which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l@{\;}}
  \VERB[RV]{xc.aesmix.enc}    &\mapsto& \VERB[RV]{mode} &=& 0                          \\
  \VERB[RV]{xc.aesmix.dec}    &\mapsto& \VERB[RV]{mode} &=& 1                          \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field.
}{
    $t_0                 \ASN                                \XCR[*][\OPER{crs1}]_{ 7 \RANGE  0}  $ \;
    $t_1                 \ASN                                \XCR[*][\OPER{crs1}]_{15 \RANGE  8}  $ \;
    $t_2                 \ASN                                \XCR[*][\OPER{crs2}]_{23 \RANGE 16}  $ \;
    $t_3                 \ASN                                \XCR[*][\OPER{crs2}]_{31 \RANGE 24}  $ \;

  \eIf{$\VERB[RV]{mode} = 0$}{
    $\XCR[*][\OPER{crd0}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}     ( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }{
    $\XCR[*][\OPER{crd0}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}^{-1}( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }
}

% =============================================================================
